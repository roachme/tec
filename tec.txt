#!/bin/env bash

# TODO: fix task ID generation
# TODO: Check that DB is inited

# Tec Task Manager
PROGRAM="tec"
VERSION="1.0.0"

# Default configuration
CONFIG_FILE=
#TEC_DB="$TEC_BASE/.tec/.tec"
PLUGINS_DIR="$HOME/.local/lib/tec/pgn"

OPT_COLOR=
OPT_DEBUG=
OPT_HOOK=
OPT_HELP=false
OPT_VERSION=false

ARG_ENV=
ARG_DESK=
ARG_TASK=

# Variables for toggle feature
ARG_ENV_CURR=
ARG_ENV_PREV=
ARG_DESK_CURR=
ARG_DESK_PREV=
ARG_TASK_CURR=
ARG_TASK_PREV=

# tree -N -C -l --noreport "$PREFIX/$path" 3>&- | tail -n +2 | sed -E 's/\.gpg(\x1B\[[0-9]+m)?( ->|$)/\1\2/g' # remove .gpg at end of line, but keep colors

_tec_db() {
    return 0;
}

die() {
    echo "$PROGRAM:" "$@" >&2
    return 1
}

unit_gen_task() {
    local fname="$1"
    local arg="$2"

    cat > "$fname" << EOF
date : $(date +"%Y-%m-%d")
type : task
prio : mid
desc : autogenerated description for task $arg
EOF
}

unit_get() {
    local env="$1"
    local desk="$2"
    local task="$3"
}

unit_set() {
    return 0;
}

#
# TOggle features: START
#
_toggle_load_env() {
    local fname="$TEC_BASE/.tec/toggles"
    [ -f "$fname" ] && source "$fname"
}

_toggle_save_env() {
    cat > "$TEC_BASE/.tec/toggles" << EOF
ARG_ENV_CURR=$ARG_ENV_CURR
ARG_ENV_PREV=$ARG_ENV_PREV
EOF
}

_toggle_load_desk() {
    local env="$1"
    local fname="$TEC_BASE/$env/.tec/toggles"
    [ -f "$fname" ] && source "$fname"
}

_toggle_save_desk() {
    local env="$1"

    cat > "$TEC_BASE/$env/.tec/toggles" << EOF
ARG_DESK_CURR=$ARG_DESK_CURR
ARG_DESK_PREV=$ARG_DESK_PREV
EOF
}

_toggle_load_task() {
    local env="$1"
    local desk="$2"

    local fname="$TEC_BASE/$env/$desk/.tec/toggles"
    [ -f "$fname" ] && source "$fname"
}

_toggle_save_task() {
    local env="$1"
    local desk="$2"

    cat > "$TEC_BASE/$env/$desk/.tec/toggles" << EOF
ARG_TASK_CURR=$ARG_TASK_CURR
ARG_TASK_PREV=$ARG_TASK_PREV
EOF
}
#
# TOggle features: END
#


check_arg_env() {
    local env="$1"

    if [ -z "$env" ]; then
        die "env not selected"
        return 1
    elif [ ! -d "$TEC_BASE/$env" ]; then
        die "'$env': env does not exist"
        return 1
    fi
    return 0
}

check_arg_desk() {
    local env="$1"
    local desk="$2"

    if ! check_arg_env "$env"; then
        return 1
    elif [ -z "$desk" ]; then
        die "desk not selected"
        return 1
    elif [ ! -d "$TEC_BASE/$env/$desk" ]; then
        die "'$desk': desk does not exist"
        return 1
    fi
    return 0
}

check_arg_task() {
    local env="$1"
    local desk="$2"
    local task="$3"

    if ! check_arg_env "$env"; then
        return 1
    elif ! check_arg_desk "$env" "$desk"; then
        return 1
    elif [ -z "$task" ]; then
        die "task not selected"
        return 1
    elif [ ! -d "$TEC_BASE/$env/$desk/$task" ]; then
        die "'$task': task does not exist"
        return 1
    fi
    return 0
}

is_plugin() {
    local pgname="$1"

    if [ -z "$pgname" ]; then
        return 1
    elif [ ! -f "$PLUGINS_DIR/$pgname/$pgname" ]; then
        return 1
    fi
    return 0
}

run_plugin() {
    local pgname="$1"
    eval "$PLUGINS_DIR/$pgname/$pgname" -T "$TEC_BASE" "$@"
}

# Load configuration
load_config() {
    if [ -f "$HOME/.tec/tec.cfg" ]; then
        CONFIG_FILE="$HOME/.tec/tec.cfg"
        source "$CONFIG_FILE"
    elif [ -f "$HOME/.config/tec/tec.cfg" ]; then
        CONFIG_FILE="$HOME/.config/tec/tec.cfg"
        source "$CONFIG_FILE"
    else
        die "could not find config file"
        return 1
    fi
}

_desk_add() {
    # Parse options
    while getopts ":e:nqN" opt; do
        case $opt in
            e) ARG_ENV="$OPTARG" ;;
            n) switch_task=false ;;
            q) quiet=true ;;
            N) switch_task=false; switch_dir=false ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    ARG_DESK="${1}"

    if ! check_arg_env "$ARG_ENV"; then
        return 1
    fi

    # TODO: check for sneaky paths
    if [ -z "$ARG_DESK" ]; then
        die "desk name not passed"
        return 1
    elif [ -d "$TEC_BASE/$ARG_ENV/$ARG_DESK" ]; then
        die "'$ARG_DESK': desk already exists"
        return 1
    fi

    mkdir -p "$TEC_BASE/$ARG_ENV/$ARG_DESK"
    mkdir -p "$TEC_BASE/$ARG_ENV/$ARG_DESK/.tec"

    ARG_DESK_PREV="$ARG_DESK_CURR"
    ARG_DESK_CURR="$ARG_DESK"

    # Create task file with basic structure
    cat > "$TEC_BASE/$ARG_ENV/$ARG_DESK/.tec/units" << EOF
DESCRIPTION='autogenerated description for env $ARG_DESK'
EOF

}

_desk_cat() {
    echo "under development"
}

_desk_cd() {
    local task_dir=

    while getopts ":e:q" opt; do
        case $opt in
            e) ARG_ENV="$OPTARG" ;;
            q) quiet=true ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done

    shift $((OPTIND-1))

    ARG_DESK="${1:-$ARG_DESK_CURR}"
    ARG_DESK="${ARG_DESK/#-/$ARG_DESK_PREV}" # '-' is an alias to previous task ID

    if ! check_arg_desk "$ARG_ENV" "$ARG_DESK"; then
        return 1
    fi

    task_dir="$TEC_BASE/$ARG_ENV/$ARG_DESK"

    ARG_DESK_PREV="$ARG_DESK_CURR"
    ARG_DESK_CURR="$ARG_DESK"
    cd "$task_dir" || return 1

    # TODO: call hooks
}

_desk_ls() {
    local env="${1:-$ARG_ENV_CURR}"

    if ! check_arg_env "$env" ; then
        return 1
    fi

    echo "List of desks"
    tree -N -C -l --noreport -L 1 "$TEC_BASE/$env" 3>&- | tail -n +2
}

_desk_mv() {
    echo "under development"
}

_desk_rm() {
    echo "under development"
}

_desk_set() {
    echo "under development"
}

_desk_sync() {
    echo "under development"
}

_env_add() {
    # TODO: add getopt option handler
    ARG_ENV="${1}"

    # TODO: check for sneaky paths
    if [ -z "$ARG_ENV" ]; then
        die "env name not passed"
        return 1
    elif [ -d "$TEC_BASE/$ARG_ENV" ]; then
        die "'$ARG_ENV': env already exists"
        return 1
    fi

    mkdir -p "$TEC_BASE/$ARG_ENV"
    mkdir -p "$TEC_BASE/$ARG_ENV/.tec"

    ARG_ENV_PREV="$ARG_ENV_CURR"
    ARG_ENV_CURR="$ARG_ENV"

    # Create task file with basic structure
    cat > "$TEC_BASE/$ARG_ENV/.tec/units" << EOF
DESCRIPTION='autogenerated description for env $ARG_ENV'
EOF
}

_env_cat() {
    echo "under development"
}

_env_cd() {
    ARG_ENV="${1:-$ARG_ENV_CURR}"

    if [ -z "$ARG_ENV" ]; then
        die "no current env or none is passed"
        return 1
    elif [ ! -d "$TEC_BASE/$ARG_ENV" ]; then
        die "'$ARG_ENV': no such env"
        return 1
    fi

    ARG_ENV_PREV="$ARG_ENV_CURR"
    ARG_ENV_CURR="$ARG_ENV"

    cd "$TEC_BASE/$ARG_ENV" || return 1
}

_env_ls() {
    echo "List of environments"
    tree -N -C -l --noreport -L 1 "$TEC_BASE" 3>&- | tail -n +2
}

_env_mv() {
    echo "under development"
}

_env_rm() {
    ARG_ENV="${1:-$ARG_ENV_CURR}"

    if [ -z "$ARG_ENV" ]; then
        die "no current env or none is passed"
        return 1
    elif [ ! -d "$TEC_BASE/$ARG_ENV" ]; then
        die "'$ARG_ENV': no such env"
        return 1
    fi

    echo "under development"
}

_env_set() {
    echo "under development"
}

_env_sync() {
    echo "under development"
}

# Generate a unique task ID
generate_task_id() {
    date +"task-%Y%m%d-%H%M%S"
}

# Add a new task
cmd_add() {
    local task_dir=
    local task_dir_db=
    local switch_task=true
    local switch_dir=true
    local quiet=false

    # Parse options
    while getopts ":d:e:nqN" opt; do
        case $opt in
            d) ARG_DESK="$OPTARG" ;;
            e) ARG_ENV="$OPTARG" ;;
            n) switch_task=false ;;
            q) quiet=true ;;
            N) switch_task=false; switch_dir=false ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    [ $# -eq 0 ] && set -- "$(generate_task_id)" # set default value

    ARG_ENV="${ARG_ENV:-$ARG_ENV_CURR}"
    ARG_DESK="${ARG_DESK:-$ARG_DESK_CURR}"

    for i in "${@}"; do
        ARG_TASK="${i}"

        if ! check_arg_desk "$ARG_ENV" "$ARG_DESK"; then
            continue
        elif [ -d "$TEC_BASE/$ARG_ENV/$ARG_DESK/$ARG_TASK" ]; then
            die "'$ARG_TASK': task ID already exists"
            continue
        fi

        task_dir="$TEC_BASE/$ARG_ENV/$ARG_DESK/$ARG_TASK"
        task_dir_db="$task_dir/.tec"

        mkdir -p "$task_dir"
        mkdir -p "$task_dir_db"

        ARG_TASK_PREV="$ARG_TASK_CURR"
        ARG_TASK_CURR="$ARG_TASK"
        _toggle_save_task "$ARG_ENV" "$ARG_DESK"

        # Create task file with basic structure
        unit_gen_task "$task_dir/.tec/units" "$ARG_TASK"
    done

    # Update current task if requested
    if [ "$switch_task" = true ]; then
        ARG_TASK_CURR="$ARG_TASK"
        if [ "$switch_dir" = true ]; then
            cd "$task_dir" 2>/dev/null || die "Could not switch to task directory"
        fi
    fi
}

cmd_cat() {
    local units=
    local task_dir=
    local keyname='.'

    while getopts ":d:e:k:nqN" opt; do
        case $opt in
            d) ARG_DESK="$OPTARG" ;;
            e) ARG_ENV="$OPTARG" ;;
            k) keyname="$OPTARG" ;;
            n) switch_task=false ;;
            q) quiet=true ;;
            N) switch_task=false; switch_dir=false ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    [ $# -eq 0 ] && set -- "$ARG_TASK_CURR" # set default value
    ARG_ENV="${ARG_ENV:-$ARG_ENV_CURR}"
    ARG_DESK="${ARG_DESK:-$ARG_DESK_CURR}"

    for i in "${@}"; do
        ARG_TASK="${i:-$ARG_TASK_CURR}"
        task_dir="$TEC_BASE/$ARG_ENV/$ARG_DESK/$ARG_TASK"
        units="$task_dir/.tec/units"

        if ! check_arg_task "$ARG_ENV" "$ARG_DESK" "$ARG_TASK"; then
            return 1
        elif [ ! -f "$units" ]; then
            die "Task $ARG_TASK does not have unit file"
            return 1
        fi

        echo "id : $ARG_TASK"
        # TODO: find a better trick cuz it returns 1
        cat "$units" | grep --color=never -E "${keyname}\s* :"

        # TODO: add hook calls
    done
}

cmd_cd() {
    local dirname=
    local task_dir=

    while getopts ":d:e:q" opt; do
        case $opt in
            d) ARG_DESK="$OPTARG" ;;
            e) ARG_ENV="$OPTARG" ;;
            q) quiet=true ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done

    shift $((OPTIND-1))

    ARG_ENV="${ARG_ENV:-$ARG_ENV_CURR}"
    ARG_DESK="${ARG_DESK:-$ARG_DESK_CURR}"
    ARG_TASK="${1:-$ARG_TASK_CURR}"
    dirname="$2"

    if [ "$ARG_TASK" = "-" ] && [ -z "$ARG_TASK_PREV" ]; then
        die "no previous task ID"
        return 1
    fi
    ARG_TASK="${ARG_TASK/#-/$ARG_TASK_PREV}" # '-' is an alias to previous task ID

    if ! check_arg_task "$ARG_ENV" "$ARG_DESK" "$ARG_TASK"; then
        return 1
    fi

    task_dir="$TEC_BASE/$ARG_ENV/$ARG_DESK/$ARG_TASK"

    if [ ! -d "$task_dir/$dirname" ]; then
        die "'$ARG_TASK': could not switch to directory '$dirname'"
        return 1
    fi

    # Prevent duplicates in toggles
    if [ "$ARG_TASK" != "$ARG_TASK_CURR" ]; then
        ARG_TASK_PREV="$ARG_TASK_CURR"
        ARG_TASK_CURR="$ARG_TASK"
    fi

    cd "$task_dir/$dirname" || return 1

    _toggle_save_task "$ARG_ENV" "$ARG_DESK"

    # TODO: call hooks
}

cmd_desk() {
    local cmd="${1:-ls}"

    case "$cmd" in
        "add")      shift; _desk_add "$@" ;;
        "cat")      shift; _desk_cat "$@" ;;
        "cd")       shift; _desk_cd "$@" ;;
        "ls")       shift; _desk_ls "$@" ;;
        "mv")       shift; _desk_mv "$@" ;;
        "rm")       shift; _desk_rm "$@" ;;
        "set")      shift; _desk_set "$@" ;;
        "sync")     shift; _desk_sync "$@" ;;
        *)          die "'$cmd': no such desk command" ;;
    esac

    if [ "$?" -eq 0 ]; then
        _toggle_save_desk "$ARG_ENV"
    fi
}

cmd_env() {
    local cmd="${1:-ls}"

    case "$cmd" in
        "add")      shift; _env_add "$@" ;;
        "cat")      shift; _env_cat "$@" ;;
        "cd")       shift; _env_cd "$@" ;;
        "ls")       shift; _env_ls "$@" ;;
        "mv")       shift; _env_mv "$@" ;;
        "rm")       shift; _env_rm "$@" ;;
        "set")      shift; _env_set "$@" ;;
        "sync")     shift; _env_sync "$@" ;;
        *)          die "'$cmd': no such env command" ;;
    esac

    if [ "$?" -eq 0 ]; then
        _toggle_save_env
    fi
}

# Show help for commands
cmd_help() {
    case "$1" in
        "tec")
            cat << EOF
Usage: $PROGRAM COMMAND [OPTION]... [ARG]...
Terminal project and task manager.

System:
  help       - Show help for commands.
  init       - Init directory structure.

Basic:
  add        - Add a new task to project.
  cat        - Show task unit values.
  cd         - Switch to task.
  desk       - Manage desks
  env        - Manage environments
  ls         - List project tasks.
  mv         - Move (rename) tasks (under development).
  rm         - Delete task from project.
  set        - Set task unit values.
  sync       - Sync (with) task ID

Run '$PROGRAM help COMMAND' to get help on specific commands.
EOF
            ;;
        "add")
            cat << EOF
Usage: $PROGRAM add [OPTION]... [ID]...
Add a new task to project.

Options:
  -h      show this help and exit
  -n      do not switch to task
  -q      do not write anything to standard error output
  -N      neither switch to task nor to task directory

Arguments:
  ID      task ID, if none passed then generated by util

Exit status:
Returns success unless task creation fails.
EOF
            ;;
        "ls")
            cat << EOF
Usage: $PROGRAM ls [OPTION]...
List project tasks.

Options:
  -a      list all tasks (including system tasks)
  -q      do not write anything to standard error output
  -H      show headers

Exit status:
Returns success unless task listing fails.
EOF
            ;;
        "cd")
            cat << EOF
Usage: $PROGRAM cd [OPTION]... [ID] [DIR]
Switch to task.

Options:
  -h      show this help and exit

Arguments:
  ID      task ID to switch to
  DIR     directory name in task directory to switch to

Exit status:
Returns success if task exists and can be switched to, otherwise fail.
EOF
            ;;
        "cat")
            cat << EOF
Usage: $PROGRAM cat [OPTION]... [ID]...
Show task unit values.

Options:
  -h      show this help and exit

Arguments:
  ID      task ID to show (default is current task)

Exit status:
Returns success if task exists, otherwise fail.
EOF
            ;;
        "rm")
            cat << EOF
Usage: $PROGRAM rm [OPTION]... [ID]...
Delete task from project.

Options:
  -q      do not write anything to standard error output
  -y      delete task without confirmation

Arguments:
  ID      task ID to delete (default is current task)

Exit status:
Returns success if task is deleted, otherwise fail.
EOF
            ;;
        "set")
            cat << EOF
Usage: $PROGRAM set OPTION... [ID]...
Set task unit values.

Options:
  -d DESC     task description
  -h          show this help and exit
  -t TYPE     task type
  -P PRIO     task priority
  -s STATUS   task status

Arguments:
  ID      task ID to modify (default is current task)

Values:
  Type    task, bugfix, feature, hotfix
  Prio    lowest, low, medium, high, highest
  Status  new, in-progress, done, blocked

Exit status:
Returns success if task is updated, otherwise fail.
EOF
            ;;
        "init")
            cat << EOF
Usage: $PROGRAM init
Init directory structure.

Exit status:
Returns success if initialization succeeds, otherwise fail.
EOF
            ;;
        "help")
            cat << EOF
Usage: $PROGRAM help [COMMAND]
Show help for commands.

If no COMMAND passed, list all commands with short description.

Arguments:
  COMMAND     builtin command

Exit status:
Returns success unless COMMAND is not found.
EOF
            ;;
        *)
            cat << EOF
System:
  help       - Show help for commands.
  init       - Init directory structure.

Basic:
  add        - Add a new task to project.
  cat        - Show task unit values.
  cd         - Switch to task.
  ls         - List project tasks.
  mv         - Move (rename) tasks (under development).
  rm         - Delete task from project.
  set        - Set task unit values.

Use '$PROGRAM help COMMAND' to get help on specific commands.
EOF
            ;;
    esac
}

# Initialize directory structure
cmd_init() {
    mkdir -p "$TEC_BASE"
    mkdir -p "$TEC_BASE/.tec"
    mkdir -p "$PLUGINS_DIR"
}

# List tasks
cmd_ls() {
    local task_dir_db=
    local show_all=false
    local quiet=false
    local show_headers=false

    # Parse options
    while getopts ":ad:qH" opt; do
        case $opt in
            a) show_all=true ;;
            d) ARG_DESK="$OPTARG" ;;
            q) quiet=true ;;
            H) show_headers=true ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    ARG_DESK="${ARG_DESK:-$ARG_DESK_CURR}"
    ARG_ENV="${1:-$ARG_ENV_CURR}"

    if ! check_arg_desk "$ARG_ENV" "$ARG_DESK"; then
        return 1
    fi

    if [ "$show_headers" = true ]; then
        printf "%-20s %-12s %-10s %-12s\n" "TASK ID" "STATUS" "TYPE" "PRIORITY"
        printf "%-20s %-12s %-10s %-12s\n" "-------" "------" "----" "--------"
    fi

    # List all task directories
    find "$TEC_BASE/$ARG_ENV/$ARG_DESK" -type d | tail -n +2 | while read -r task_dir; do
        local units="$task_dir/.tec/units"

        # TODO: show error in case of missing unit file or invalid content
        if [ -f "$units" ]; then
            task_id=$(basename "$task_dir")
            echo "column $task_id      some description"
        fi
    done
}

cmd_mv() {
    echo "under development"
}

# Delete task
cmd_rm() {
    local quiet=false
    local confirm=true

    # Parse options
    while getopts ":d:e:qy" opt; do
        case $opt in
            d) ARG_DESK="$OPTARG" ;;
            e) ARG_ENV="$OPTARG" ;;
            y) confirm=false ;;
            q) quiet=true ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    [ $# -eq 0 ] && set -- "$ARG_TASK_CURR" # set default value
    ARG_ENV="${ARG_ENV:-$ARG_ENV_CURR}"
    ARG_DESK="${ARG_DESK:-$ARG_DESK_CURR}"

    for i in "${@}"; do
        ARG_TASK="${i:-$ARG_TASK_CURR}"

        if ! check_arg_task "$ARG_ENV" "$ARG_DESK" "$ARG_TASK"; then
            continue
        fi

        # Confirm deletion unless forced
        if [ "$confirm" = true ]; then
            # TODO: use option -p for prompt. It does not work on zsh
            printf "%s" "Delete task '${ARG_TASK}' ? [y/N] "
            read -r choice
            if [ "$choice" != "y" ] && [ "$choice" != "Y" ]; then
                echo "Abort"
                continue
            fi
        fi

        # Update current task if it was the deleted one
        if [ "$ARG_TASK_PREV" = "$ARG_TASK" ]; then
            ARG_TASK_PREV=
        fi
        if [ "$ARG_TASK_CURR" = "$ARG_TASK" ]; then
            ARG_TASK_CURR="$ARG_TASK_PREV"
            ARG_TASK_PREV=
        fi

        # Delete task directory
        rm -rf "${TEC_BASE:?}/$ARG_ENV/$ARG_DESK/$ARG_TASK"
    done

    _toggle_save_task "$ARG_ENV" "$ARG_DESK"
}

# Set task properties
cmd_set() {
    local task_id="$ARG_TASK_CURR"
    local description=""
    local task_type=""
    local priority=""
    local status=""

    # Parse options
    while getopts ":d:t:P:s:" opt; do
        case $opt in
            d) description="$OPTARG" ;;
            t) task_type="$OPTARG" ;;
            P) priority="$OPTARG" ;;
            s) status="$OPTARG" ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    # TODO: add logic
}

cmd_sync() {
    echo "under development"
}

cmd_version() {
    echo "$PROGRAM version $VERSION"
}

tec() {
    local command=

    # TODO: add option handlers: -H, -C, -D, etc
    # TODO: fix options `-h' and `-v'
    while getopts ":hvC:D:H:" opt; do
        case $opt in
            h) OPT_HELP=true ;;
            v) OPT_VERSION=true ;;
            C) OPT_COLOR="$OPTARG" ;;
            D) OPT_DEBUG="$OPTARG" ;;
            H) OPT_HOOK="$OPTARG" ;;
            *) die "Invalid option \`-$OPTARG'"; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    command="${1:-help}"
    #[ "$OPT_HELP" = true ] && command="help"
    #[ "$OPT_VERSION" = true ] && command="version"
    #echo "command: $command"

    case "$command" in
        "add")          shift; cmd_add "$@" ;;
        "cd")           shift; cmd_cd "$@" ;;
        "cat")          shift; cmd_cat "$@" ;;
        "desk")         shift; cmd_desk "$@" ;;
        "env")          shift; cmd_env "$@" ;;
        "help")         shift; cmd_help "$@" ;;
        "init")         shift; cmd_init "$@" ;;
        "ls")           shift; cmd_ls "$@" ;;
        "mv")           shift; cmd_mv "$@" ;;
        "rm")           shift; cmd_rm "$@" ;;
        "set")          shift; cmd_set "$@" ;;
        "sync")         shift; cmd_sync "$@" ;;
        "version")      shift; cmd_version "$@" ;;
        *)
            if is_plugin "$command"; then
                run_plugin "$@"
            else
                die "$command: command not found"
            fi
            ;;
    esac
}

if ! load_config; then
    return 1
fi

# TODO: simplify this shit
_toggle_load_env
if [ -n "$ARG_ENV_CURR" ]; then
    _toggle_load_desk "$ARG_ENV_CURR"
    if [ -n "$ARG_DESK_CURR" ]; then
        _toggle_load_task "$ARG_ENV_CURR" "$ARG_DESK_CURR"
    fi
fi

#tec "$@"
